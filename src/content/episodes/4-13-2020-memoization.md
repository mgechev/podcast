---
title: Memoization
description: Today we'll learn about memoization! Memoization is a practice that helps us improve the performance of our apps using caching. In the episode, we'll also discuss pure functions, caching strategies, and much more!
audio: https://anchor.fm/s/ff47d524/podcast/play/96292363/https%3A%2F%2Fd3ctxlq1ktw2nl.cloudfront.net%2Fstaging%2F2024-11-26%2F392135401-44100-2-67a8d555e01da76c.mp3
publish: true
---

Today we'll learn about memoization! Memoization is a practice that helps us improve the performance of our apps using caching.

In the episode, we'll also discuss pure functions, caching strategies, and much more!

- [Memo decorator for JavaScript](https://github.com/mgechev/memo-decorator)
- [Quiz on pure functions](https://twitter.com/radokirov/status/1097325661658570752)
- [Cache replacement strategies (LRU and much more)](https://en.wikipedia.org/wiki/Cache_replacement_policies)

**Transcript**

Episode 16 - Memoization

00:00:02 - 00:05:07

welcome to the programming podcast. Here you can learn about computers in the brief and accessible way I'm your host mean could get. Hello everyone today in the priming podcast to discuss another practical computer. Science concepts Colt Memorization. In general memorization is a practice. That can help us improve the performance of our programs with relation we're taking E. Function and returning Amen. Wise version of this function which means that every time we invoke this function with the same set of arguments instead of free computing the result which is going to take it directly from the cash. This means that whilst we involve function with certain set of arguments we're going to take the result and put it into a cash associating it with the arguments that invokes the function with the next time we worked the function with the exact same set of arguments instead of going through the logic of recommitting the result directly to pull it up from the cash and return it so I mentioned functions but this practice is quiet useful for maths as well. Because methods they're just functions invoked into the context for certain objects that they're attached to so. Where have I use memorization? To be honest. If you meant religion probably thousands of times you can use it everywhere especially when you have a very heavy function that performs a very heavy computation. You can use memorization in speed up. This function for each next invocation. Let me share a particular example with you where I used them in a business application so I was putting a platform for children education. We're pretty much teaching children on math. And we wanted to gain fighters platform. So what we did was to show the progress of the kids in some kind of a fun way which was also used for and it was comparing a kit with its peers. This way we were computing. A lot of different things based on statistical calculations so based on all the children's performance. We were coming up with the result which was comparing the child's performance with its pierce and this function was performing quiet. A few computations which work redundant because we were invoking this particular function with the performance results for a certain limited set of children so whilst we compute the result for channels A. We really don't have re compute it until we have some new data right so instead of free computing. This result every time when displaying gets on the user interface to this what we did was to apply memorization. We calculated this result. Only once and right after that on each subsequent invocation of this function instead of going through all the different computations we just pull the result out from the cash and return it so this may sound like Greg Catholic but memorization is more powerful because takes your function and transforms. It's a new function which performs this man was Asian. This functional concept of them is very quiet interrelated with some other concepts from object oriented programming from for example from the aspirated program. Inquiry can apply certain piece of floor before and after the function. But this is not the focus for this episode so we have an entire episode only cashing rights only about memorization. And probably most of your sounds like a lot of redundancy. We should be ready by now right. We already know what's Musician. We're just cashing some results. All of the functions execution right. Nothing to complicate it. Well there are quite a bit. Tricky things with memorization so just by memorizing the results of a function. You can shoot yourself in the food pretty easy when you should consider whether you're memorizing the results from a pure faction or if you're Function is impure. Another thing is how are you going to cash referential types you imagine you have the exact same object like business? Object represented with different objects. Different references inside of your program. How are you going to cares us? And a third example for a complication is around memory leaks and Mary consumption so today. We're going to stop on all these three complications and discuss what we should consider. In these cases let's start with pure versus impure functions generally function in functional programming. A pure function is a function that when invoked the same set of arguments always returns the same result and on top of that it also does not produce any side effects.


00:05:08 - 00:10:02

This may sound like a simple definition again. It's probably of quiet obvious pure function. And what isn't but severe honest. It's one of the most complicated things ever. It is like it is enforced only by the compiler and this is the only thing that can hint. Function is pure impure of course. It is easy to judge about purity to certain extent but imagine we have a function which returns on the Ray with one element. Let's say with the element zero. So if we Vogel's function twice working to get an array with new reference every time right which means if we compare the result of the invocation of two subsequently evocations of dysfunction. We're going to get two different results if we performed with reference check because we have always on the ray which one element and this element zero. But we're getting different references to this array every time because we were creating inury at the same time however if we don't perform reference check we're going to get through and this function is going to be pure. See how things depend on context to extent. Anyway why is purity important for memorization? Remember that we said that were cashing results with keys. The arguments of the function which means that we need to have the guarantee that involved function with the same set of arguments. We're going to get the same result. Alternatively the function is consuming some global. Object somewhere in our program. We don't have those guarantee at all because the result of the function is dependent not only on its arguments but also this global at object. That's it accesses so this could be quite tricky and definitely not recommended to use memorization with impure functions. Because you can just waste a lot of memory and you may not even returned correct results right because there is a lot of the function is not dependent by its arguments. Second Referential Types of Keys. Imagine we have the user type and we can create different users so we can create user. A which has and well we can create many objects for user with the right so we can have hundreds different instances of this user object which is pretty much representing the exact same business entity the user a in our system but these are different references so if use the reference of the object as a key for memorization we are not going to succeed because each new user each user pretty much has its own different reference and whilst if we cash a certain result which is performing an operation on user. We are always going to cash Result associated with the current reference that we have evolved the function wits. So in this case instead of using the object as a key during memorization. I'll recommend you to use. Its idee because it's what is making the object unique right. We are not considering the reference in this particular case as an identifier of this particular argument of the function. But instead we're considering a particular property these are psyche and the third thing does at want us to discuss. Today is memory. The memory consumption is probably the trickiest. Imagine if we're invoking our function wit hundreds or thousands of different types of objects which can produce thousands of different keys and hundreds of thousands of results that we're going to cash associated with these keys. This can waste a lot of memory especially in programs which are executed for awhile for awhile over time. That's why we can use different caching strategies for example we can cash just the most recent and you -cations of the function instead of catching all of them completely matter function uses take advantage of weak maps for example the week map is a javascript data structure which allows us to clean up some of the records that we have in the week map. They're no longer referenced. In memory of the garbage collector has already gotten rid of them and this extremely convenient for implementing cashing fermentation as well because we will no longer be referencing. These garbage collected object. So they're going to create any memories. That's pretty much everything today.


00:10:02 - 00:10:40

That's what I wanted to share with you. What is meant was Asian and death. You should be pretty careful with it but at the same time. It is very powerful for making sure that you're not performing any redundant calculations. I apply different resources in the page associated with this episodes. These heavily there at podcast dealt am dot com. Thank you very much for listening. Learn about the episode's You can follow me on twitter at Ham. The resources and recordings is available at podcast dot M. dot com. Thanks for listening.
